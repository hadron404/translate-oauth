# Introduction 前言

> ​	**In** the traditional `client-server` authentication model, the `client` requests an access-restricted resource (protected resource) on the server by authenticating with the server using the `resource owner's` credentials.
>
> In order to provide third-party applications access to restricted resources, the resource owner shares its credentials with the third party. 

​	**在**传统的`客户端-服务器`验证模型里，客户端通过使用`资源所有者`的凭据进行服务器验证，在服务器上请求一个访问受限的资源（受保护资源）。为了让第三方应用访问受限资源，资源所有者与第三方分享它的凭据。

> This creates several problems and limitations:
>
> * Third-party applications are required to store the resource owner's credentials for future use, typically a password in clear-text.
> * Servers are required to support password authentication, despite the security weaknesses inherent in passwords.
> * Third-party applications gain overly broad access to the resource owner's protected resources, leaving resource owners without any ability to restrict duration or access to a limited subset of resources.
> * `Resource owners` often reuse passwords with other unrelated services, despite bets security practices. This password reuse means a vulnerability or exposure in one service may have security implications in completely unrelated services.
> * `Resource owners` cannot revoke access to an individual third party without revoking access to all third parties, and must do so by changing their password.
> * Compromise of any third-party application results in compromise of the end-user's password and all of the data protected by that password.

这产生了一些问题和限制：

* 第三方应用需要存储资源所有者的凭据以便将来使用，（凭据）往往是一个明文密码。
* 尽管密码存在固有的弱安全性，服务器（还是）需要支持密码验证。
* 第三方应用取得资源所有者过大的资源访问（权限），资源所有者不具备限制（访问权限的）持续时间或者（访问权限）访问一个有限的资源子集的能力。
* 尽管有最佳安全实践，但资源所有者经常在其他不相关的服务上重用密码。这种密码重用意味着一个漏洞即一个服务的暴露可能会给其他完全不相关的服务带来安全隐患。
* 资源所有者无法撤销单个第三方应用的访问（权限）而不撤销所有第三方应用的访问（权限），必须通过更换密码来做。
* 任何第三方应用程序的泄露都会导致用户密码和受该密码保护的所有数据的泄露。